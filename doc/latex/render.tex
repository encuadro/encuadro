\chapter{Herramientas de \textit{rendering}}
\section{Introducción}
\textit{Rendering} es un término en inglés que denota el proceso de generar una imagen 2D a partir de un modelo digital 3D o un conjunto de ellos, a los que se les llama ``escena''. Puede ser comparado con tomar una foto o filmar una escena en la vida real. Afortunadamente, existen varias herramientas de \textit{rendering} para plataformas móviles, en especial que funcionen sobre iOS, algunas de ellas serán comentadas a continuación.\\ 

La primera en ser tomada en cuenta fue ``Open Graphics Library Embedded Systems'' (Open GL ES), que es un subconjunto de las herramientas de gráficos 3D de Open GL. Fue dise\~nado para ser utilizado sobre sistemas embebidos (dispositivos móviles, consolas de video juegos, etc.); Open GL es el estándar más ampliamente usado alrededor del mundo para la creación de gráficos 2D y 3D, es grátis y multiplataforma. Como la programación en Open GL y en particular en Open GL ES es de muy bajo nivel y por lo tanto bastante complicada, se optó por investigar otras herramientas. La primera que se encontró fue ``ISGL3D''. ISGL3D es un \textit{framework} (marco de trabajo) escrito en Objective-C que trabaja sobre Open GL ES y que busca facilitar la tarea del programador a la hora de crear y manipular escenas 3D mediante una ``\textit{Application Program Interface}'' (API) sencilla e intuitiva. Es un proyecto grátis y en código abierto. Luego de algunas semanas de trabajo con la herramienta e importantes avances desde el punto de vista del manejo de la misma se descubrió la existencia de otro \textit{framework} de idénticas llamado ``Cocos3D''. Cocos3D es una extensión de ``Cocos2D'', una herramienta para la generación de gráficos 2D,  muy popular entre los desarrolladores de aplicaciones para iOS. Como no se identificaron diferencias significativas entre ISGL3D y Cocos3D, se priorizó el tiempo dedicado a ISGL3D y se decidió continuar trabajando de forma inalterada. Al día de hoy, sobre el final del proyecto, se cree que si bien técnicamente ambos \textit{frameworks} son muy buenos y a la vez similares entre sí, Cocos3D cuenta con una comunidad mucho más activa, lo que facilita mucho su uso.\\

En este capítulo se comentarán algunas características y conceptos de ISGL3D que fueron importantes para el proyecto;  por detalles de algunos temas en particular referirse a la referencia de la ya mencionada API en: \url{www.isgl3d.com/resources/api}.  Además se trazará una hoja de ruta para todo aquel que quiera iniciarse en el manejo de la herramienta.\\

\section{ISGL3D}
ISGL3D es un \textit{framework} para \textit{iPad}, \textit{iPhone} y \textit{iPod touch} escrito en \textit{Objective-C}, que sirve para crear escenas y \textit{renderizarlas} de forma sencilla. Es un proyecto en código abierto y gratis. En su sitio web oficial: \url{www.isgl3d.com}, se puede descargar su código, y de forma sencilla ISGL3D puede ser agregado como un complemento de \textit{Xcode}. Además se pueden encontrar tutoriales, detalles de su API y un acceso a un grupo de \textit{google} donde la comunidad pregunta y responde dudas propias y ajenas. Una buena manera de iniciarse en manejo de la herramienta es siguiendo los tutoriales en: \url{www.isgl3d.com/resources/tutorials}; al menos este fué el camino elegido por el grupo. Los tutoriales son 6, y abarcan distintos tópicos:
\begin{itemize}
\item \textbf{Tutorial 0:} primer paso en el creado de una aplicación ISGL3D. Cubre algunos conceptos básicos y muestra cómo integrar la herramienta a \textit{Xcode}.
\item \textbf{Tutorial 1:} mustra cómo crear una escena bien simple, con tan sólo un cubo en rotación continua.
\item \textbf{Tutorial 2:} ense\~na cómo agregar luz a una escena. Se ven las distintas fuentes de luz que existen en el \textit{framework}.
\item \textbf{Tutorial 3:} se ve cómo hacer para mapear texturas en los objetos 3D con el objetivo de hacrlos más realistas.
\item \textbf{Tutorial 4:} muestra cómo crear interacción entre el usuario y los distintos objetos ISGL3D, cuando este los toca a través de la pantalla.
\item \textbf{Tutorial 5:} se ven algunas nuevas primitivas y se muestra cómo \textit{renderizar} objetos con transparencia.
\end{itemize}

Al descargar e instalar ISGL3D, se puede ver que la herramienta incluye un proyecto \textit{Xcode} integrado por varios ejemplos para ejecutar y a la vez ver su código, otra buena forma de aprender cómo realizar distintas tareas de interés. Entre los ejemplos se encuentra ``la solución'' a cada uno de los tutoriales.\\ 

Cuando se crea una aplicación ISGL3D, el núcleo de la misma es la llamada ``\textit{view}'' (``vista'' en Espa\~nol ). Una \textit{view} esta compuesta principalmente por una escena y una cámara:
\begin{itemize}
\item Una \textbf{escena} (Isgl3dScene3D) es donde los objetos o modelos 3D son agregados como nodos. Todos los nodos pueden ser tanto trasladados como rotados y pueden tener otros nodos hijos; los nodos hijos son trasladados y rotados con sus padres. Así como objetos 3D, se pueden agregar luces de distinto tipo, que generarán en la escena efectos de sombra que luego serán adecuadamente \textit{renderizados} en función de dónde se encuentre y hacia dónde este mirando la cámara.
\item Una \textbf{cámara} que es utilizada para para ver la escena desde una posición y un ángulo en particular. La cámara se manipula como cualquier otro objeto o nodo en la escena, se puede trasladar, rotar y hasta indicar hacia dónde quiere uno que la cámara apunte. Es importante ajustar la cámara de manera que su arquitectura sea la que uno busca. Se pueden entonces ajustar ciertos parámetros intrínsecos a esta como por ejemplo su campo visual, su distancia focal, la altura y la anchura del plano imagen, etc.
\end{itemize}
Es importante entender que el llamado \textit{render} se realiza sumando la información de la escena, objetos 3D y sus hijos, luces, etc.; más la información de dónde se encuentra la cámara, sus características y hacia dónde esta apunta.\\

Un particularidad de la cámara de ISGL3D es que el parámetro intrínseco ``distancia focal'' visto la sección \ref{sec:Calibracion de camara}, no es directamente configurable. En cambio, el valor que sí se puede alterar es el llamado ``FOV'', acónimo de ``Fiel Of View''. El \textit{field of view} de una cámara no es más que su campo visual, y se mide como la extensión angular máxima mapeable en el plano imagen, medida desde el centro óptico \textit{C}. Puede ser medido de forma horizontal o de forma vertical; sin embargo, en ISGL3D es definido verticalmente. Ver figura \ref{fig:render1}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{figs_render/render1}
\caption{Definición gráfica del FOV.}
\label{fig:render1}
\end{figure}

Realizando algo de geometría se ve que la relación entre la distancia focal y el FOV es:
\[
FOV = 2.arctg\left(\frac{h}{2.f}\right)
\]
donde $h$ denota la altura del plano imagen y $f$ la distancia focal de la cámara.\\

ISGL3D cuanta con algunas estructuras primitivas que pueden ser usadas como modelos, o incluso combinadas de manera de formar modelos algo más complejos. Las principales estructuras primitivas de ISGL3D son:
\begin{itemize}
\item \textbf{Isgl3DArrow:} modelo correspondiente a una flecha. Tiene 4 parámetros configurables:
\begin{itemize}
\item \textit{headHeight:} altura de la punta.
\item \textit{headRadius:} radio de la punta.
\item \textit{height:} altura total de la flecha.
\item \textit{radius:} radio de la base.
\end{itemize} 
\item \textbf{Isgl3DCone:} modelo correspondiente a un cono. Tiene 3 parámetros configurables:
\begin{itemize}
\item \textit{bottomRadius:} radio de la base inferior.
\item \textit{height:} altura del cono.
\item \textit{topRadius:} radio de la base superior.
\end{itemize}
\item \textbf{Isgl3DCube:} modelo correspondiente a un cubo. Tiene 3 parámetros configurables:
\begin{itemize}
\item \textit{depth:} profundidad del cubo. 
\item \textit{height:} altura del cubo.
\item \textit{width:} anchura del cubo.
\end{itemize}
\item \textbf{Isgl3DCylinder:} modelo correspondiente a un cilindro. Tiene 3 parámetros configurables:
\begin{itemize}
\item \textit{height:} altura del cilindio.
\item \textit{radius:} radio del cilindro.
\item \textit{openEnded:} indica si el cilindro cuenta con sus extremos abiertos o no.
\end{itemize}
\item \textbf{Isgl3DEllipsoid:} modelo correspondiente a una elipsoide. Cuenta con 3 parámetros configurables:
\begin{itemize}
\item \textit{radiusX:} radio de la elipsoide en la dirección \textit{x}.
\item \textit{radiusY:} radio de la elipsoide en la dirección \textit{y}.
\item \textit{radiusZ:} radio de la elipsoide en la dirección \textit{z}.
\end{itemize}
\item \textbf{Isgl3DOvoid:} modelo ovoide. Cuenta con 3 parámetros configurables:
\begin{itemize}
\item \textit{a:} radio del ovoide en la dirección \textit{x}. 
\item \textit{b:} radio del ovoide en la dirección \textit{y}.
\item \textit{k:} factor que modifica la forma de la curva. Cuando toma el valor 0, el modelo se corresponde con el de una ellipsoide.
\end{itemize}
\item \textbf{Isgl3DSphere:} modello correspondiente a una esfera. Tiene un único parámetro configurable:
\begin{itemize}
\item \textit{radius:} radio de la esfera.
\end{itemize}
\item \textbf{Isgl3DTorus:} modelo correspondiente a un toroide. Cuenta con 2 parámetros configurables:
\begin{itemize}
\item \textit{radius:} radio desde el origen del toroide hasta el centro del tubo.
\item \textit{tubeRadius:} radio del tubo del toroide.
\end{itemize}
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.2]{figs_render/render2}
\caption{Principales primitivas en ISGL3D.}
\label{fig:render2}
\end{figure}

Para la creación de cada primitiva, se debe especificar además, la cantidad de segmentos utilizados en las distintas dimensiones. En la figura \ref{fig:render2} se pueden ver todas las primitivas anteriores. Es fácil ver que dichas primitivas cuentan con cierta textura cuadriculada de colores rojo y blanco, que fue lograda mapeando una imagen sobre cada una de ellas. La porción de código que se usó para realizar tal mapeo se muestra a continuación:\\
\footnotesize
\begin{verbatim}
Isgl3dTextureMaterial * material = [Isgl3dTextureMaterial
                  materialWithTextureFile:@"red_checker.png" shininess:0.9];
	
Isgl3dTorus * torusMesh = [Isgl3dTorus meshWithGeometry:2 tubeRadius:1 ns:32 nt:32];

Isgl3dMeshNode * _torus = [self.scene createNodeWithMesh:torusMesh andMaterial:material];
\end{verbatim}

\normalsize
En la primera línea de código se crea el material. Dicho material es del tipo \textit{Isgl3dTextureMaterial}; y la imagen con la que este se crea es la de la figura \ref{fig:render3}. Luego, se crea el toroide asignándole los parámetros vistos más atrás en esta sección; y finalmente, se crea y se agrega a la escena el nodo asociado al toroide, con el material creado al principio. \\

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{figs_render/red_checker}
\caption{Imagen \textit{red$\_$checker.png}, utilizada para crear la textura asociada a las primitivas de la figura \ref{fig:render2}.}
\label{fig:render3}
\end{figure}

A veces lo que se quiere no es agregar a la escena una primitiva sino un modelo previamente creado. Los modelos son realizados en herramientas de creado y animación de gráficos 3D como por ejemplo \textit{Blender}, \textit{MeshLab}, \textit{Autodesk Maya} o \textit{Autodesk 3ds Max}. Luego deben ser exportados en un formato llamado \textit{COLLADA}, acrónimo de ``COLLAborative Design Activity'', que sirve para el intercambio de contenido digital 3D entre distintas aplicaciones de modelado. Por su parte, ISGL3D permite importar modelos pero en un formato llamado \textit{POD}. Se usó entonces, una aplicación llamada \textit{Collada2POD} que lo que hace es convertir modelos tridimensionales en formato \textit{COLLADA} al formato \textit{POD}. \textit{Collada2POD} puede ser descargada gratuitamente de la página oficial de \textit{Imagination Technologies}, su desarrollador: \url{http://www.imgtec.com/}.\\

Una vez que se tiene al objeto 3D en el formato \textit{POD}, este puede ser importado en ISGL3D de forma sencilla:\\
\footnotesize
\begin{verbatim}
Isgl3dPODImporter * podImporter = [Isgl3dPODImporter podImporterWithFile:@``modelo.pod''];

Isgl3dNode * _model = [self.scene createNode];

[podImporter addMeshesToScene:_model];

 _model.position = iv3(2, 6, 0);
\end{verbatim}

\normalsize
En la primera línea de código se instancia la clase \textit{Isgl3dPODImporter} que sirve para transformar modelos POD a objetos ISGL3D, y se le asigna a la misma el modelo \textit{modelo.pod}. Luego, se crea un nodo llamado ``$\_$model'', al que se le asignará el modelo; y se agrega a la escena. Finalmente, se le asigna al modelo una posición. En la figura \ref{fig:render4} se puede ver un modelo de José Artigas, agregado dos veces a una misma escena, pero visto desde ángulos distintos.\\

\begin{figure}[h!]
\centering
\includegraphics[scale=0.2]{figs_render/render4}
\caption{Modelo de José Artigas agregado dos veces en una misma escena, pero visto desde ángulos distintos.}
\label{fig:render4}
\end{figure}

Si lo que se quiere es que los modelos sean animados, o lo que es lo mismo, que tengan movimiento, hay dos soluciones posibles a tomar en consideración:

\begin{itemize}
\item{\textbf{Modelo animado}}: muchas veces lo que se tiene es un modelo 3D animado desde su construcción. Estos pueden ser creados, al igual que los modelos 3D inanimados, con las herramientas para el creado y la animación de gráficos 3D antedichas. Existe mucha bibliografía al respecto, además de haber múltiples sitios en internet de donde bajar los modelos, incluso en forma gratuita. Luego de obtenido el modelo animado, lo que se tendrá será precisamente al modelo, pero con una línea de tiempo con las animaciones. Nuevamente, habrá que convertirlo a formato POD para ser usado en ISGL3D. El código para poder visualizar al modelo será:
\footnotesize
\begin{verbatim}
Isgl3dPODImporter * podImporter = [Isgl3dPODImporter 
             podImporterWithFile:@"animated_model.pod"];

Isgl3dSkeletonNode *_model = [self.scene createSkeletonNode];
   
[podImporter addMeshesToScene:_model];
   
Isgl3dAnimationController * _animationController = [[Isgl3dAnimationController alloc] 
            initWithSkeleton:_model andNumberOfFrames:[podImporter numberOfFrames]];
                                    
[_animationController start];
\end{verbatim}
\normalsize
En la primera línea de código se instancia la clase \textit{Isgl3dPODImporter}, y se le asigna a la misma el modelo animado ``animated$\_$model.pod''.  Luego, se crea y se agrega a la escena un nodo del tipo \textit{Isgl3dSkeletonNode} llamado ``$\_$model'' que contendrá al modelo animado. La clase \textit{Isgl3dSkeletonNode} provee una interfaz sencilla para animar al ahora objeto ISGL3D, que con la ayuda de la clase \textit{Isgl3dAnimationController}, logra automatizar el movimiento del mismo. Finalmente, se instancia y configura la clase \textit{Isgl3dAnimationController} y se le da inicio a la animación en la última línea.\\

\item\textbf{Múltiples modelos inanimados:}
\end{itemize}

