\chapter{Herramientas de \textit{rendering}}
\section{Introducción}
\textit{Rendering} es un término en inglés que denota el proceso de generar una imagen 2D a partir de un modelo digital 3D o un conjunto de ellos, a los que se les llama ``escena''. Puede ser comparado con tomar una foto o filmar una escena en la vida real. Afortunadamente, existen varias herramientas de \textit{rendering}, también llamadas ``motores de juego 3D'', para plataformas móviles, en especial que funcionen sobre iOS. Algunas de ellas son Unity 3D, ISGL3D, Cocos3D, Open GL ES y ShiVa3D. A continuación serán comentadas tan sólo las consideradas durante el presente proyecto por ser populares y gratuitas.\\

La primera en ser tomada en cuenta fue ``Open Graphics Library Embedded Systems'' (Open GL ES), que es un subconjunto de las herramientas de gráficos 3D de Open GL. Fue dise\~nada para ser utilizada sobre sistemas embebidos (dispositivos móviles, consolas de video juegos, etc.); Open GL es el estándar más ampliamente usado alrededor del mundo para la creación de gráficos 2D y 3D, es gratis y multiplataforma. Como la programación en Open GL y en particular en Open GL ES es de muy bajo nivel y por lo tanto bastante complicada, se optó por investigar otras herramientas. Se descubrió entonces ISGL3D un \textit{framework} escrito en Objective-C que trabaja sobre Open GL ES y que busca facilitar la tarea del programador al momento de crear y manipular escenas 3D mediante una ``\textit{Application Program Interface}'' (API) sencilla e intuitiva. Es un proyecto gratis y en código abierto. Luego de algunas semanas de trabajo con la herramienta e importantes avances desde el punto de vista del manejo de la misma se descubrió la existencia de otro \textit{framework} de idénticas características llamado ``Cocos3D''. Cocos3D es una extensión de ``Cocos2D'', una herramienta para la generación de gráficos 2D,  muy popular entre los desarrolladores de aplicaciones para iOS. Como no se identificaron diferencias significativas entre ISGL3D y Cocos3D, se priorizó el tiempo dedicado a ISGL3D y se decidió continuar trabajando de forma inalterada. Al día de hoy, sobre el final del proyecto, se cree que si bien técnicamente ambos \textit{frameworks} son muy buenos y a la vez similares entre sí, ISGL3D parece estar algo más avanzado en cuanto a su desarrollo. Sin embargo debido a la gran popularidad de Cocos2D, Cocos3D ha heredado muchos usuarios y cuenta con una comunidad mucho más activa, lo que facilita mucho su uso y hace pensar que en un futuro cercano resulte en un \textit{framework} más desarrollado.\\

En este capítulo se comentarán algunas características y conceptos de ISGL3D que fueron importantes para el proyecto;  por detalles de algunos temas en particular referirse a la referencia de la ya mencionada API en: \url{www.isgl3d.com/resources/api}.  Además se trazará una hoja de ruta para todo aquel que quiera iniciarse en el manejo de la herramienta.\\

\section{ISGL3D}
ISGL3D es un motor de juegos 3D para \textit{iPad}, \textit{iPhone} y \textit{iPod touch} escrito en \textit{Objective-C}, que sirve para crear escenas y \textit{renderizarlas} de forma sencilla. Es un proyecto en código abierto y gratis. En su sitio web oficial: \url{www.isgl3d.com}, se puede descargar su código, y de forma sencilla ISGL3D puede ser agregado como un complemento de \textit{Xcode}. Además se pueden encontrar tutoriales, detalles de su API y un acceso a un grupo de \textit{Google} donde la comunidad pregunta y responde dudas propias y ajenas. Una buena manera de iniciarse en manejo de la herramienta es siguiendo los tutoriales en: \url{www.isgl3d.com/resources/tutorials}; al menos este fue el camino elegido por el grupo. Los tutoriales son 6, y abarcan distintos tópicos:
\begin{itemize}
\item \textbf{Tutorial 0:} primer paso en el creado de una aplicación ISGL3D. Cubre algunos conceptos básicos y muestra cómo integrar la herramienta a \textit{Xcode}.
\item \textbf{Tutorial 1:} mustra cómo crear una escena bien simple, con tan sólo un cubo en rotación continua.
\item \textbf{Tutorial 2:} ense\~na cómo agregar luz a una escena. Se ven las distintas fuentes de luz que existen en el \textit{framework}.
\item \textbf{Tutorial 3:} se ve cómo hacer para mapear texturas en los objetos 3D con el objetivo de hacerlos más realistas.
\item \textbf{Tutorial 4:} muestra cómo crear interacción entre el usuario y los distintos objetos ISGL3D, cuando este los toca a través de la pantalla.
\item \textbf{Tutorial 5:} se ven algunas nuevas primitivas (modelos básicos) y se muestra cómo agregar transparencia a los objetos.
\end{itemize}

Al descargar e instalar ISGL3D, se puede ver que la herramienta incluye un proyecto \textit{Xcode} integrado por varios ejemplos para ejecutar y a la vez ver su código, otra buena forma de aprender cómo realizar distintas tareas de interés. Entre los ejemplos se encuentra la solución a cada uno de los tutoriales.\\ 

Cuando se crea una aplicación ISGL3D, el núcleo de la misma es la llamada ``\textit{view}'' (``vista'' en Espa\~nol ). Una \textit{view} está compuesta principalmente por una escena y una cámara:
\begin{itemize}
\item Una \textbf{escena} (\textit{Isgl3dScene3D}) es donde los objetos o modelos 3D son agregados como nodos. Todos los nodos pueden ser tanto trasladados como rotados y pueden tener otros nodos hijos; los nodos hijos son trasladados y rotados con sus padres. Así como objetos 3D, se pueden agregar luces de distinto tipo, que generarán en la escena efectos de sombra que luego serán adecuadamente \textit{renderizados} en función de dónde se encuentre y hacia dónde este mirando la cámara.
\item Una \textbf{cámara} que es utilizada para para ver la escena desde una posición y un ángulo en particular. La cámara se manipula como cualquier otro objeto o nodo en la escena, se puede trasladar, rotar y hasta indicar hacia dónde quiere uno que esta apunte. Es importante ajustar la cámara de manera que su arquitectura sea la que uno busca. Se pueden entonces ajustar ciertos parámetros intrínsecos a esta como por ejemplo su campo visual, su distancia focal, la altura y la anchura del plano imagen, etc.
\end{itemize}
Es importante entender que el llamado \textit{render} se realiza sumando la información de la escena, objetos 3D y sus hijos, luces, etc.; más la información de dónde se encuentra la cámara, sus características y hacia dónde esta apunta.\\

Un particularidad de la cámara de ISGL3D es que el parámetro intrínseco ``distancia focal'' visto la sección \ref{sec:Calibracion de camara}, no es directamente configurable. En cambio, el valor que sí se puede alterar es el llamado ``FOV'', acónimo de ``Field Of View''. El \textit{field of view} de una cámara no es más que su campo visual, y se mide como la extensión angular máxima mapeable en el plano imagen, medida desde el centro óptico \textit{C}. Puede ser medido de forma horizontal o de forma vertical; sin embargo, en ISGL3D es definido verticalmente. Ver figura \ref{fig:render1}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{figs_render/render1}
\caption{Definición gráfica del FOV.}
\label{fig:render1}
\end{figure}

Realizando algo de geometría se ve que la relación entre la distancia focal y el FOV es:
\[
FOV = 2.arctg\left(\frac{h}{2.f}\right)
\]
donde $h$ denota la altura del plano imagen y $f$ la distancia focal de la cámara.\\

ISGL3D cuenta con algunas estructuras primitivas que pueden ser usadas como modelos, o incluso combinadas de manera de formar modelos algo más complejos. Las principales estructuras primitivas de ISGL3D son:
\begin{itemize}
\item \textbf{Isgl3DArrow:} modelo correspondiente a una flecha. Tiene 4 parámetros configurables:
\begin{itemize}
\item \textit{headHeight:} altura de la punta.
\item \textit{headRadius:} radio de la punta.
\item \textit{height:} altura total de la flecha.
\item \textit{radius:} radio de la base.
\end{itemize} 
\item \textbf{Isgl3DCone:} modelo correspondiente a un cono. Tiene 3 parámetros configurables:
\begin{itemize}
\item \textit{bottomRadius:} radio de la base inferior.
\item \textit{height:} altura del cono.
\item \textit{topRadius:} radio de la base superior.
\end{itemize}
\item \textbf{Isgl3DCube:} modelo correspondiente a un cubo. Tiene 3 parámetros configurables:
\begin{itemize}
\item \textit{depth:} profundidad del cubo. 
\item \textit{height:} altura del cubo.
\item \textit{width:} anchura del cubo.
\end{itemize}
\item \textbf{Isgl3DCylinder:} modelo correspondiente a un cilindro. Tiene 3 parámetros configurables:
\begin{itemize}
\item \textit{height:} altura del cilindio.
\item \textit{radius:} radio del cilindro.
\item \textit{openEnded:} indica si el cilindro cuenta con sus extremos abiertos o no.
\end{itemize}
\item \textbf{Isgl3DEllipsoid:} modelo correspondiente a una elipsoide. Cuenta con 3 parámetros configurables:
\begin{itemize}
\item \textit{radiusX:} radio de la elipsoide en la dirección \textit{x}.
\item \textit{radiusY:} radio de la elipsoide en la dirección \textit{y}.
\item \textit{radiusZ:} radio de la elipsoide en la dirección \textit{z}.
\end{itemize}
\item \textbf{Isgl3DOvoid:} modelo ovoide. Cuenta con 3 parámetros configurables:
\begin{itemize}
\item \textit{a:} radio del ovoide en la dirección \textit{x}. 
\item \textit{b:} radio del ovoide en la dirección \textit{y}.
\item \textit{k:} factor que modifica la forma de la curva. Cuando toma el valor 0, el modelo se corresponde con el de una ellipsoide.
\end{itemize}
\item \textbf{Isgl3DSphere:} modello correspondiente a una esfera. Tiene un único parámetro configurable:
\begin{itemize}
\item \textit{radius:} radio de la esfera.
\end{itemize}
\item \textbf{Isgl3DTorus:} modelo correspondiente a un toroide. Cuenta con 2 parámetros configurables:
\begin{itemize}
\item \textit{radius:} radio desde el origen del toroide hasta el centro del tubo.
\item \textit{tubeRadius:} radio del tubo del toroide.
\end{itemize}
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.2]{figs_render/render2}
\caption{Principales primitivas en ISGL3D.}
\label{fig:render2}
\end{figure}

Para la creación de cada primitiva, se debe especificar además, la cantidad de segmentos que la forman en las distintas dimensiones. En la figura \ref{fig:render2} se pueden ver todas las primitivas anteriores. Es fácil ver que dichas primitivas cuentan con cierta textura cuadriculada de colores rojo y blanco, que fue lograda mapeando una imagen sobre cada una de ellas. La porción de código que se usó para realizar tal mapeo se muestra a continuación:\\
\footnotesize
\begin{verbatim}
Isgl3dTextureMaterial * material = [Isgl3dTextureMaterial
                  materialWithTextureFile:@"red_checker.png" shininess:0.9];
	
Isgl3dTorus * torusMesh = [Isgl3dTorus meshWithGeometry:2 tubeRadius:1 ns:32 nt:32];

Isgl3dMeshNode * _torus = [self.scene createNodeWithMesh:torusMesh andMaterial:material];
\end{verbatim}

\normalsize
En la primera línea de código se crea el material. Dicho material es del tipo \textit{Isgl3dTextureMaterial}; y la imagen con la que este se crea es la de la figura \ref{fig:render3}. Luego, se crea el toroide asignándole los parámetros vistos más atrás en esta sección; y finalmente, se crea y se agrega a la escena el nodo asociado al toroide, con el material creado al principio. \\

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{figs_render/red_checker}
\caption{Imagen \textit{red$\_$checker.png}, utilizada para crear la textura asociada a las primitivas de la figura \ref{fig:render2}.}
\label{fig:render3}
\end{figure}

A veces lo que se quiere no es agregar a la escena una primitiva sino un modelo previamente creado. Los modelos son realizados en herramientas de creado y animación de gráficos 3D como por ejemplo \textit{Blender}, \textit{MeshLab}, \textit{Autodesk Maya} o \textit{Autodesk 3ds Max}. Luego deben ser exportados en un formato llamado \textit{COLLADA}, acrónimo de ``COLLAborative Design Activity'', que sirve para el intercambio de contenido digital 3D entre distintas aplicaciones de modelado. Por su parte, ISGL3D permite importar modelos pero en un formato llamado ``POD''. Se usó entonces, una aplicación llamada \textit{Collada2POD} que lo que hace es convertir modelos tridimensionales en formato \textit{COLLADA} al formato POD. \textit{Collada2POD} puede ser descargada gratuitamente de la página oficial de \textit{Imagination Technologies}, su desarrollador: \url{http://www.imgtec.com}.\\

Una vez que se tiene al objeto 3D en el formato requerido, este puede ser importado en ISGL3D de forma sencilla:\\
\footnotesize
\begin{verbatim}
Isgl3dPODImporter * podImporter = [Isgl3dPODImporter podImporterWithFile:@``modelo.pod''];

Isgl3dNode * _model = [self.scene createNode];

[podImporter addMeshesToScene:_model];

 _model.position = iv3(2, 6, 0);
\end{verbatim}

\normalsize
En la primera línea de código se instancia la clase \textit{Isgl3dPODImporter} que sirve para transformar modelos POD a objetos ISGL3D, y se le asigna a la misma el modelo ``modelo.pod''. Luego, se crea un nodo llamado ``$\_$model'', al que se le asigna el modelo; y se agrega a la escena. Finalmente, se le asigna al nodo una posición. En la figura \ref{fig:render4} se puede ver un modelo de José Artigas, agregado dos veces a una misma escena, pero visto desde ángulos distintos.\\

\begin{figure}[h!]
\centering
\includegraphics[scale=0.2]{figs_render/render4}
\caption{Modelo de José Artigas agregado dos veces en una misma escena, pero visto desde ángulos distintos.}
\label{fig:render4}
\end{figure}

Si lo que se quiere es que los modelos sean animados, o lo que es lo mismo, que tengan movimiento, hay dos soluciones posibles a tomar en consideración:

\begin{itemize}
\item{\textbf{Modelo animado}}: muchas veces lo que se tiene es un modelo 3D animado desde su construcción. Estos pueden ser creados, al igual que los modelos 3D inanimados, con las herramientas para el creado y la animación de gráficos 3D antedichas. Existe mucha bibliografía al respecto, además de haber múltiples sitios en internet de donde bajar los modelos, incluso en forma gratuita. Luego de obtenido el modelo animado, lo que se tiene es precisamente al modelo, pero con una línea de tiempo con las animaciones. Nuevamente, hay que convertirlo a formato POD para ser usado en ISGL3D. El código para poder visualizar al modelo es:
\footnotesize
\begin{verbatim}
Isgl3dPODImporter * podImporter = [Isgl3dPODImporter 
             podImporterWithFile:@"animated_model.pod"];

Isgl3dSkeletonNode *_model = [self.scene createSkeletonNode];
   
[podImporter addMeshesToScene:_model];
   
Isgl3dAnimationController * _animationController = [[Isgl3dAnimationController alloc] 
            initWithSkeleton:_model andNumberOfFrames:[podImporter numberOfFrames]];
                                    
[_animationController start];
\end{verbatim}
\normalsize
En la primera línea de código se instancia la clase \textit{Isgl3dPODImporter}, y se le asigna a la misma el modelo animado ``animated$\_$model.pod''.  Luego, se crea y se agrega a la escena un nodo del tipo \textit{Isgl3dSkeletonNode} llamado ``$\_$model'' que contiene al modelo animado. La clase \textit{Isgl3dSkeletonNode} provee una interfaz sencilla para animar al ahora objeto ISGL3D, que con la ayuda de la clase \textit{Isgl3dAnimationController}, logra automatizar el movimiento del mismo. Finalmente, se instancia y configura la clase \textit{Isgl3dAnimationController} y se le da inicio a la animación en la última línea.\\

\item\textbf{Múltiples modelos inanimados:} otra forma de animar un modelo 3D es usando múltiples modelos inanimados. Estos pueden ser cargados en ISGL3D como un único objeto o nodo y mediante ciertas instrucciones sencillas, se le dice al \textit{framework} que presente uno a continuación del otro, interpolando entre posiciones contiguas, lo que genera una sensación de movimento. Este fue el método utilizado en el presente proyecto para animar al modelo de José Artigas. En la figura \ref{fig:render5} se puede ver al mismo en 3 posiciones distintas.\\

\begin{figure}[h!]
\centering
\includegraphics[scale=0.2]{figs_render/artigases}
\caption{Modelo de José Artigas en 3 posiciones distintas, utilizadas  para generar en ISGL3D una sensación de movimiento.}
\label{fig:render5}
\end{figure}

El código para realizar la interpolación mencionada, aplicado por ejemplo a dos modelos, será:
\footnotesize
\begin{verbatim}
Isgl3dPODImporter * podImporter = [Isgl3dPODImporter 
          podImporterWithFile:@"model_1.pod"];

[podImporter buildSceneObjects];
        
Isgl3dPODImporter * podImporter2 = [Isgl3dPODImporter 
         podImporterWithFile:@"model_2.pod"];

[podImporter2 buildSceneObjects];

Isgl3dGLMesh* _modelMesh = [podImporter meshAtIndex:0 ];
 
Isgl3dGLMesh* _modelMesh2 = [podImporter2 meshAtIndex:0 ];

Isgl3dKeyframeMesh * _mesh = [Isgl3dKeyframeMesh keyframeMeshWithMesh:_modelMesh];
          
[_mesh addKeyframeMesh:_modelMesh2];
        
[_mesh addKeyframeAnimationData:0 duration:1.0f];
[_mesh addKeyframeAnimationData:0 duration:2.0f];
[_mesh addKeyframeAnimationData:1 duration:1.0f];
[_mesh addKeyframeAnimationData:1 duration:2.0f];

[_mesh startAnimation];

Isgl3dNode * node = [_container createNodeWithMesh:_mesh 
          andMaterial:[podImporter materialWithName:@"material_0"]];

node.position = iv3(-90, -60, -150);

[podImporter addMeshesToScene:node];
\end{verbatim}
\normalsize
En las primeras 4 líneas de código se instancia en dos oportunidades la clase \textit{Isgl3dPODImporter}, y se les asigna a las instancias los modelos inanimados ``model$\_$1.pod'' y ``model$\_$2.pod'. La instrucción \textit{buildSceneObjects} crea todos los objetos de la escena del modelo POD, pero no los agrega a la escena ISGL3D. Luego se obtienen los modelos indexados de cada uno de los PODs (cada POD puede tener una escena con más de un modelo. Mediante un índice se referencia qué modelo se quiere obtener) y se almacenan en ``$\_$modelMesh'' y ``$\_$modelMesh2'' respectivamente. Se genera a continuación un nuevo modelo al que se le asignan los dos modelos anteriores, luego se programa la animación y se le da inicio mediante la instrucción \textit{startAnimation}. Finalmente, se genera un nuevo objeto o nodo ISGL3D al que se le asigna el modelo, y un material también cargado desde el archivo POD; se le asigna además una posición y se lo agrega a la escena. 
\end{itemize}

